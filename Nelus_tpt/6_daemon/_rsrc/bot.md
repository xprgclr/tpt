## в чем отличия sudo cmake -DCMAKE_INSTALL_PREFIX=/usr ../ и sudo cmake  ../

Команда `cmake` используется для сборки проектов из исходного кода с использованием инструкций из файлов `CMakeLists.txt`. Она генерирует файлы проекта, которые затем используются для компиляции и установки программы.

В вашем вопросе различие между командами `sudo cmake -DCMAKE_INSTALL_PREFIX=/usr ../` и `sudo cmake ../` заключается в переданных параметрах `CMAKE_INSTALL_PREFIX`.

1. **`sudo cmake -DCMAKE_INSTALL_PREFIX=/usr ../`**:
   - В этой команде вы передаете параметр `-DCMAKE_INSTALL_PREFIX=/usr` команде `cmake`. Этот параметр указывает путь, куда установщик будет копировать собранные файлы после того, как проект будет собран и установлен.
   - В данном случае указывается путь `/usr`, что обычно является стандартным местом установки системных программ и библиотек во многих дистрибутивах Linux. Программы, установленные в этот каталог, становятся частью системы и доступны всем пользователям.
   - Поэтому эта команда соберет проект и установит его в каталог `/usr`.

2. **`sudo cmake ../`**:
   - Это более обычный способ запуска `cmake`, без указания дополнительных параметров, таких как `CMAKE_INSTALL_PREFIX`.
   - В этом случае cmake будет использовать значения по умолчанию, которые указаны в файле `CMakeLists.txt`. Это может включать в себя установку в другие каталоги по умолчанию, которые могут не совпадать с `/usr`.
   - Результат сборки и установки будет зависеть от настроек, определенных в `CMakeLists.txt`, и места, указанного в конфигурации cmake (например, каталог сборки).

Таким образом, основное отличие между этими двумя командами заключается в том, что первая явно указывает каталог установки `/usr`, тогда как вторая использует значения по умолчанию, указанные в конфигурации проекта.


## что делает make после этого ?

Команда `make` используется после `cmake` для фактической сборки проекта, основываясь на инструкциях, которые были сгенерированы `cmake` из файлов `CMakeLists.txt`.

Когда вы выполняете `sudo cmake -DCMAKE_INSTALL_PREFIX=/usr ../`, cmake создает файлы проекта и инструкции для сборки в соответствии с вашими параметрами, включая указание пути установки `/usr`.

После того как cmake сгенерировал файлы проекта, вы вызываете `make`. Это инициирует компиляцию проекта на основе инструкций, сгенерированных cmake. Make будет компилировать исходные файлы вашего проекта в исполняемые файлы или библиотеки, в зависимости от того, что описано в `CMakeLists.txt`.

В результате вы получите готовые к использованию исполняемые файлы, библиотеки или другие компоненты проекта, которые были скомпилированы в соответствии с инструкциями, указанными в `CMakeLists.txt`.


## а make install потом ?

Да, после успешной компиляции проекта с использованием `make` следует выполнить `make install`. Команда `make install` копирует скомпилированные файлы (исполняемые файлы, библиотеки, заголовочные файлы и другие ресурсы) в указанный вами каталог установки. 

Когда вы указываете `sudo cmake -DCMAKE_INSTALL_PREFIX=/usr ../`, вы задаете `/usr` как каталог установки. Поэтому после успешной компиляции проекта с помощью `make`, `make install` скопирует файлы в указанный каталог, что позволит программам и системе обращаться к этим файлам и использовать их.

Вот как обычно выглядит последовательность действий при сборке и установке проекта с помощью CMake:

1. `cmake <путь к исходным файлам>`: Генерация файлов проекта на основе `CMakeLists.txt`.
2. `make`: Компиляция проекта на основе сгенерированных файлов проекта.
3. `sudo make install`: Установка скомпилированных файлов в указанный каталог установки (в вашем случае - `/usr`).



## скрит для etc/init.d

Этот скрипт создает и устанавливает инициализационный скрипт для службы `simple-daemon`. Разберем его по частям:

1. Создание файла инициализации: `cat << end > /etc/init.d/simple-daemon`: Эта строка использует конструкцию "here document" для создания файла `/etc/init.d/simple-daemon` и направляет вывод в этот файл.

2. Информация о начальной загрузке: Этот блок содержит метаданные о начальной загрузке, такие как уровни запуска и остановки службы.

3. `set -e`: Это устанавливает режим, в котором скрипт будет автоматически завершаться, если какая-либо команда в нем завершится с ненулевым статусом выхода.

4. `Source function library`: Эта строка подключает библиотеку функций инициализации LSB, которая содержит функции для работы с инициализационными скриптами.

5. `run_by_init()`: Это функция, которая проверяет, запущен ли скрипт из инициализации.

6. Функции `start()` и `stop()`: Они отвечают за запуск и остановку службы `simple-daemon`.

7. Переменная `prg`: Она содержит имя программы, связанной с этим инициализационным скриптом.

8. `case "$1" in ... esac`: Это конструкция ветвления, которая основывается на аргументе, переданном скрипту, и выполняет соответствующее действие (`start`, `stop`, `restart`, `status`).

9. `exit 0`: Это завершает скрипт с кодом выхода 0, что обычно означает успешное выполнение.

Таким образом, этот скрипт позволяет управлять запуском, остановкой, перезапуском и проверкой статуса службы `simple-daemon`.