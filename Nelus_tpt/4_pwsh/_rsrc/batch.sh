#!/bin/bash

# Запуск по: 
# echo 0 1 2 5 true false five | ./batch.sh v9 
# Или просто:
# ./batch.sh
# Можно запускать без указания данных в трубе и/или имени файла в аргументах скрипта - тогда подставятся значения по умолчанию.
# Значения по умолчанию применяются как для имени файла, так и для данных в трубе.
# Тестировал только на своём варианте.Можно попробовать и с другими вариантами, но я думаю что 
# В лучшем случае съедет форматирование первой строчки # т.к у меня отключен перевод на новую строку -
# для компактности вывода работы скрипта именно моего варианта.
# В худшем случае они не выполнятся т.к некоторые ps1 скрипты ожидают только int значения, а не строки ("test","true","false")
# А в некоторых скриптах данные ожидаются не по трубе, а в виде параметра.
###########################################################################################################################


# Значение по умолчанию для имени файла, без расширения (чтобы не вводить две переменные для*.awk и *.ps1 файла,
# различающихся только расширением (проще прибавить строку расширения к этой переменной, когда будем к ней обращаться)
default_file_name="v9"

# Значение по умолчанию для передаваемых данных по трубе, если мы их не ввели
default_pipe_data=(0 1 2 true false test)

# Вырубаем отладку, она только мешает тут
set +x

# Проверяем наличие входного параметра - пусть это будет имя файла
if [ -z "$1" ]; then
  # Входной параметр отсутствует, устанавливаем ему значение по умолчанию
  script_name="$default_file_name"
else
  # Входной параметр присутствует, используем его значение
  script_name="$1"
fi

# Проверяем, существует ли вообще awk и ps1 файл, нужного нам варианта. Если одного из них нет - выходим
if [ ! -e "$script_name.awk" ] ; then
  echo "file $script_name.awk not found.. exit"
  exit 1
elif [ ! -e "$script_name.ps1" ]; then
  echo "file $script_name.ps1 not found.. exit"
  exit 1
fi

# Чтение данных из трубы, если они доступны
if [ -p /dev/stdin ]; then
    read -a input_data
else
    # Если данных в трубе нет, то просим ввести, либо используем наши значения по умолчанию
    echo "Write data separated by spaces, or press Enter for default values ( 0 1 2 5 true false test ) "
    read -a input_data
    # Использование данных или установка значений по умолчанию
    if [ ${#input_data[@]} -eq 0 ]; then
      input_data=("${default_pipe_data[@]}")
    fi
fi

echo "Comparing the behaviour in AWK & Poweshell script..."

# Запускаем awk для каждого входного значения по трубе
for input in "${input_data[@]}"; do
    # Выводим пользователю какие данные читаем в трубе, в очередном цикле
    echo "-----sending value \""$input"\" through a pipe ----------------->"

    # Используем AWK файл для обработки текущего элемента и вывода результата
    echo -n -e "  :-->\t" to a AWK script: "\t\t-> Result: " && echo "$input" | awk -f "$script_name.awk" || break

    # Используем PowerShell файл для обработки текущего элемента и вывода результата
    echo -n -e "  :--> \t" to a Powershell script: "\t-> Result: " && echo "$input" | pwsh "$script_name.ps1" || break

    # P.S: break нам особо тут уже не нужны, т.к они были тут вписаны тут еще до того как решил сделать проверку на наличие файла
    # в начале скрипта, но пусть уже останется - чтоб наверняка)
    
    # Переходим на новую строку
    echo -e
done


echo "-------------------- DONE ------------------------------"


